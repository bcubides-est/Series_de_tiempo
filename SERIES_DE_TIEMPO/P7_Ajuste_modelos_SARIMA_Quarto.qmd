---
title: "Ajuste SARIMA (Completo)"
author: "Brayan Cubides"
toc: true
toc-location: right
toc-depth: 2
#number-sections: true
code-tools: true
lightbox: true
self-contained: false  
---

# Ejercicio de ajuste modelo SAIMA

Ajuste de la serie de pasajeros basada en *Time Series Analysis - With Applications in R, 2nd Ed*.

------------------------------------------------------------------------

## Librerías necesarias

```{r, fig.width=20, fig.height=5, out.width="100%", echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(urca)
library(forecast)
library(tseries)
library(lmtest)
library(uroot)
library(fUnitRoots)
library(aTSA)
```

------------------------------------------------------------------------

## Parte 1: Raíz Unitaria

Se simula un ARIMA(1,1,1) y se prueban raíces unitarias.\
La prueba ADF considera: $$
\Delta X_t = \rho\,X_{t-1} + \sum_{j=1}^p\beta_j\,\Delta X_{t-j} + e_t.
$$

```{r, fig.width=20, fig.height=5, out.width="100%"}
# Raiz Unitaria
Tlength = 200
arimaej_raiz_unit = arima.sim(list(order = c(1,1,1), ar = 0.7, ma = 0.6),
                              n = Tlength)
layout(matrix(c(1,1,2, 1,1,3), nc = 2))
par(mar=c(3,3,2,1), mgp=c(1.6,.6,0))
plot(arimaej_raiz_unit)
acf(arimaej_raiz_unit)
pacf(arimaej_raiz_unit)

# Ho: Raiz unitaria (no estacionaria) vs Ha: Estacionariedad
tseries::adf.test(arimaej_raiz_unit)       # p.valor>0.05 ⇒ no rechaza Ho

# Prueba KPSS (Ho: estacionariedad vs Ha: raiz unitaria)
tseries::kpss.test(arimaej_raiz_unit)      # p.valor<0.05 ⇒ rechaza estacionariedad

# Prueba Phillips-Perron (Ho: raiz unitaria vs Ha: estacionariedad)
tseries::pp.test(arimaej_raiz_unit)        # p.valor>0.05 ⇒ no rechaza Ho
```

**Interpretación:**\
Las pruebas ADF y PP no rechazan raíz unitaria, mientras KPSS rechaza estacionariedad ⇒ la serie simulada no es estacionaria.

------------------------------------------------------------------------

## Parte 2: Transformación y raíces unitarias en AirPassengers

### 2.1 Estabilizar varianza

Box–Cox indica $\lambda\approx0$ ⇒ aplicar $\log$:

```{r, fig.width=20, fig.height=5, out.width="100%"}
data("AirPassengers")
par(mfrow=c(1,1))
plot(AirPassengers)
forecast::BoxCox.lambda(AirPassengers, method="guerrero", lower=0)
forecast::BoxCox.lambda(AirPassengers, method="loglik",   lower=0)
logAirP = log(AirPassengers)

par(mfrow=c(2,1))
plot(AirPassengers, main="Original")
plot(logAirP,      main="Logaritmo natural")
```

### 2.2 Detectar raíces unitarias regulares y estacionales

```{r, fig.width=20, fig.height=5, out.width="100%"}
par(mfrow=c(2,1))
acf(logAirP, lag.max = 60)
pacf(logAirP)

# ADF con drift y tendencia
tseries::adf.test(logAirP)     # p.valor>=0.01 ⇒ no rechaza Ho

# KPSS (Ho: estacionariedad)
tseries::kpss.test(logAirP)    # p.valor<0.05 ⇒ rechaza estacionariedad

# PP (Ho: raiz unitaria)
tseries::pp.test(logAirP)      # p.valor>=0.01 ⇒ no rechaza Ho

# ADF aumentado
aTSA::adf.test(logAirP, nlag = 8)
```

```{r, fig.width=20, fig.height=5, out.width="100%"}
# Decisión de diferencias
ndiffs(logAirP)   # d = 1
nsdiffs(logAirP)  # D = 1
```

**Interpretación:**\
Se requieren una diferencia regular ($d=1$) y una estacional ($D=1$) para estacionarizar.

------------------------------------------------------------------------

## Parte 3: Diferencias y verificación

```{r, fig.width=20, fig.height=5, out.width="100%"}
# Diferencia regular
dlogAirPass = diff(logAirP)

par(mfrow=c(3,1))
plot(AirPassengers); plot(logAirP); plot(dlogAirPass)

par(mfrow=c(2,1))
acf(dlogAirPass, lag.max = 48)
pacf(dlogAirPass)
aTSA::adf.test(dlogAirPass, nlag = 15)

# Diferencia estacional
d_dlogAirPass = diff(dlogAirPass, 12)

par(mfrow=c(4,1))
plot(AirPassengers); plot(logAirP); plot(dlogAirPass); plot(d_dlogAirPass)

par(mfrow=c(2,1))
acf(d_dlogAirPass, lag.max = 50)
pacf(d_dlogAirPass, lag.max = 50)
aTSA::adf.test(d_dlogAirPass, nlag = 15)
```

**Interpretación:**\
Tras $d=1, D=1$, la serie estacionariza: ACF y PACF ya no muestran picos periódicos ni tendencia.

------------------------------------------------------------------------

## Parte 4: Ajuste de posibles modelos SARIMA

Se prueban tres modelos con transformación $\lambda=0$:

```{r, fig.width=20, fig.height=5, out.width="100%"}
# 1) ARIMA(1,1,1)x(0,1,1)[12]
Mod1 = forecast::Arima(
  AirPassengers,
  order    = c(1,1,1),
  seasonal = c(0,1,1),
  lambda   = 0,
  method   = "ML"
)

# 2) ARIMA(0,1,1)x(0,1,1)[12]
Mod2 = forecast::Arima(
  AirPassengers,
  order    = c(0,1,1),
  seasonal = c(0,1,1),
  lambda   = 0,
  method   = "ML"
)

# 3) ARIMA(1,1,0)x(0,1,1)[12]
Mod3 = forecast::Arima(
  AirPassengers,
  order    = c(1,1,0),
  seasonal = c(0,1,1),
  lambda   = 0,
  method   = "ML"
)

Mod2; Mod3
```

**Interpretación:**\
Los criterios AIC/BIC prefieren **Mod2**: ARIMA(0,1,1)x(0,1,1)\[12\].

------------------------------------------------------------------------

## Parte 5: Diagnóstico de Mod2

```{r, fig.width=20, fig.height=5, out.width="100%"}
at_est <- residuals(Mod2)
tsdiag(Mod2)

# Normalidad de residuos
library(car); library(nortest)
ad.test(at_est); shapiro.test(at_est)

hist(at_est, freq=FALSE)
lines(density(at_est), col="red", lwd=2)
qqnorm(at_est); qqline(at_est, col=2)
```

**Interpretación:**\
Residuos no muestran autocorrelación ni alejados de normalidad ⇒ modelo adecuado.

------------------------------------------------------------------------

## Parte 6: CUSUM y CUSUMQ

```{r, fig.width=20, fig.height=5, out.width="100%"}
cum  = cumsum(at_est)/sd(at_est)
N    = length(at_est)
cumq = cumsum(at_est^2)/sum(at_est^2)
Af   = 0.948  # 95% CUSUM
co   = 0.14013

LS   = Af*sqrt(N) + 2*Af*(1:N)/sqrt(N)
LI   = -LS
LQS  = co + (1:N)/N
LQI  = -co + (1:N)/N

par(mfrow=c(2,1))
plot(cum,  type="l", ylim=c(min(LI),max(LS)), main="CUSUM");  lines(LS, col="red"); lines(LI, col="red")
plot(cumq, type="l", main="CUSUMSQ"); lines(LQS, col="red"); lines(LQI, col="red")
```

**Conclusiones:**\
- **CUSUM:** sin cambio estructural.\
- **CUSUMQ:** posible heterocedasticidad moderada ⇒ probar ARCH.

------------------------------------------------------------------------

## Parte 7: Pronóstico

```{r, fig.width=20, fig.height=5, out.width="100%"}
par(mfrow=c(1,1))
pronosticos12 = forecast::forecast(Mod2, h=12, level=0.95)
plot(pronosticos12)

# Con ggplot2
AirPassengers %>%
  forecast::Arima(order=c(0,1,1), seasonal=c(0,1,1), lambda=0, method="ML") %>%
  forecast::forecast(h=12) %>%
  autoplot()
```

**Uso práctico:**\
Las proyecciones con bandas de confianza guían decisiones de capacidad y planificación en transporte aéreo.

### Notas de modelado SARIMA

-   Identificar $d,D$ con `ndiffs`, `nsdiffs`.\
-   ACF estacional: picos en múltiplos de 12 ⇒ componente SMA o SAR.\
-   PACF estacional: corte en orden $P$.\
-   Validar residuos (Ljung–Box, normalidad).\
-   Ajuste iterativo: simplificar términos insignificantes.

Este flujo implementa el método Box–Jenkins para datos estacionales.
